/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "tuplas.h"
#include "servidor.h"

// We'll use semaphores to control the access as readers/writers
#include <semaphore.h>
#include <pthread.h>

LinkedList *list = NULL;

// The wait() and post() semaphores are atomic -> do not assure order

sem_t writer_sem;										// semaphores for readers and writers
pthread_mutex_t reader_mut = PTHREAD_MUTEX_INITIALIZER; // mutex for the reader_count variable and its initialization
int reader_count = 0;									// number of readers reading
bool is_semaphore_initialized = false;					// semaphore initialization flag
bool is_list_created = false;							// linked list creation flag

void init_sem()
{
	// Initialize the semaphore
	pthread_mutex_lock(&reader_mut);
	if (!is_list_created)
	{
		list = create_linked_list();
		is_list_created = true;
	}

	if (!is_semaphore_initialized)
	{
		sem_init(&writer_sem, 0, 1);
		is_semaphore_initialized = true;
	}
	pthread_mutex_unlock(&reader_mut);
}

bool_t
init_1_svc(int *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;

	// Initialize the semaphore if it is not initialized
	init_sem();

	// Writer tries to get the write semaphore
	sem_wait(&writer_sem);

	// initialize linked list
	*result = init_ll(list);

	// Writer releases the write semaphore
	sem_post(&writer_sem);

	return retval;
}

bool_t
set_value_1_svc(Value value, int *result,  struct svc_req *rqstp)
{
	bool_t retval = TRUE;

	// Initialize the semaphore if it is not initialized
	init_sem();

	// Writer tries to get the write semaphore
	sem_wait(&writer_sem);

	// Insert request in the linked list
	*result = set_value_ll(list, value.key, value.value1, value.value2, value.value3);

	// Writer releases the write semaphore
	sem_post(&writer_sem);

	display_list(list);

	return retval;
}

bool_t
get_value_1_svc(int key, Value *result,  struct svc_req *rqstp)
{
	bool_t retval = TRUE;

	// Initialize the semaphore if it is not initialized
    init_sem();

    // Acquire the reader mutex
    pthread_mutex_lock(&reader_mut);

    // Increment the reader count
    reader_count++;

    // If it's the first reader, try to get the write semaphore
    if (reader_count == 1)
    {
        if (sem_trywait(&writer_sem) != 0)
        {
            pthread_mutex_unlock(&reader_mut);
            sem_post(&writer_sem);
            return -1; // return error code indicating that the lock was not acquired
        }
    }

    // Release the reader mutex
    pthread_mutex_unlock(&reader_mut);

    // Get request from the linked list
    if (list != NULL)
    {
        *result = get_value(list, key, value1, value2, value3);
    }
    else
    {
        *result = -1;
    }

    // Acquire the reader mutex
    pthread_mutex_lock(&reader_mut);

    // Decrement the reader count
    reader_count--;

    // If it's the last reader, release the write semaphore
    if (reader_count == 0)
    {
        sem_post(&writer_sem);
    }

    // Release the reader mutex
    pthread_mutex_unlock(&reader_mut);

	display_list(list);

	return retval;
}

bool_t
modify_value_1_svc(Value value, int *result,  struct svc_req *rqstp)
{
	bool_t retval = TRUE;

    // Initialize the semaphore if it is not initialized
    init_sem();

    // Writer tries to get the write semaphore
    sem_wait(&writer_sem);

    // Create request
    *result = modify_value(list, key, value1, value2, value3);

    // Writer releases the write semaphore
    sem_post(&writer_sem);

	display_list(list);

	return retval;
}

bool_t
delete_key_1_svc(int key, int *result,  struct svc_req *rqstp)
{
	bool_t retval = TRUE;

	// Initialize the semaphore if it is not initialized
    init_sem();

    // Writer tries to get the write semaphore
    sem_wait(&writer_sem);

    // Delete request from the linked list
    *result = delete_key(list, key);

    // Writer releases the write semaphore
    sem_post(&writer_sem);

	display_list(list);

	return retval;
}

bool_t
exist_1_svc(int key, int *result,  struct svc_req *rqstp)
{
	bool_t retval = TRUE;

	// Initialize the semaphore if it is not initialized
    init_sem();

    // Acquire the reader mutex
    pthread_mutex_lock(&reader_mut);

    // Increment the reader count
    reader_count++;

    // If it's the first reader, try to get the write semaphore
    if (reader_count == 1)
    {
        if (sem_trywait(&writer_sem) != 0)
        {
            pthread_mutex_unlock(&reader_mut);
            sem_post(&writer_sem);
            return -1; // return error code indicating that the lock was not acquired
        }
    }

    // Release the reader mutex
    pthread_mutex_unlock(&reader_mut);

    // Check if key exists in the linked list
    *result = exist(list, key);

    // Acquire the reader mutex
    pthread_mutex_lock(&reader_mut);

    // Decrement the reader count
    reader_count--;

    // If it's the last reader, release the write semaphore
    if (reader_count == 0)
    {
        sem_post(&writer_sem);
    }

    // Release the reader mutex
    pthread_mutex_unlock(&reader_mut);

	display_list(list);

	return retval;
}

bool_t
copy_key_1_svc(TwoKeys keys, int *result,  struct svc_req *rqstp)
{
	bool_t retval = TRUE;

	// Initialize the semaphore if it is not initialized
    init_sem();

    // Writer tries to get the write semaphore
    sem_wait(&writer_sem);

    // Copy request from key1 to key2 in the linked list
    *result = copy_key(list, key1, key2);

    // Writer releases the write semaphore
    sem_post(&writer_sem);

	display_list(list);

	return retval;
}

int
tuple_service_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
